//
// Generated by Bluespec Compiler, version 2017.03.beta1 (build 35049, 2017-03-16)
//
// On Tue Feb 18 19:14:50 IST 2020
//
//
// Ports:
// Name                         I/O  size props
// get                            O    32 reg
// RDY_get                        O     1
// RDY_put                        O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_datas                      I    32 reg
// EN_put                         I     1
// EN_get                         I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkHardware(CLK,
		  RST_N,

		  EN_get,
		  get,
		  RDY_get,

		  put_datas,
		  EN_put,
		  RDY_put);
  input  CLK;
  input  RST_N;

  // actionvalue method get
  input  EN_get;
  output [31 : 0] get;
  output RDY_get;

  // action method put
  input  [31 : 0] put_datas;
  input  EN_put;
  output RDY_put;

  // signals for module outputs
  wire [31 : 0] get;
  wire RDY_get, RDY_put;

  // register clk
  reg [31 : 0] clk;
  wire [31 : 0] clk$D_IN;
  wire clk$EN;

  // register count
  reg [31 : 0] count;
  wire [31 : 0] count$D_IN;
  wire count$EN;

  // register send
  reg [31 : 0] send;
  wire [31 : 0] send$D_IN;
  wire send$EN;

  // ports of submodule dut
  wire [31 : 0] dut$get, dut$put_datas;
  wire dut$EN_get, dut$EN_put, dut$RDY_get, dut$RDY_put;

  // ports of submodule in_fifo
  wire [31 : 0] in_fifo$D_IN, in_fifo$D_OUT;
  wire in_fifo$CLR, in_fifo$DEQ, in_fifo$EMPTY_N, in_fifo$ENQ, in_fifo$FULL_N;

  // ports of submodule outQ
  wire [31 : 0] outQ$D_IN, outQ$D_OUT;
  wire outQ$CLR, outQ$DEQ, outQ$EMPTY_N, outQ$ENQ, outQ$FULL_N;

  // actionvalue method get
  assign get = outQ$D_OUT ;
  assign RDY_get = send < 32'd6 && outQ$EMPTY_N ;

  // action method put
  assign RDY_put = count < 32'd6 && in_fifo$FULL_N ;

  // submodule dut
  mkCpu dut(.clk(CLK),
	    .reset(RST_N),
	    .put_datas(dut$put_datas),
	    .EN_put(dut$EN_put),
	    .EN_get(dut$EN_get),
	    .RDY_put(dut$RDY_put),
	    .get(dut$get),
	    .RDY_get(dut$RDY_get));

  // submodule in_fifo
  FIFO2 #(.width(32'd32), .guarded(32'd1)) in_fifo(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(in_fifo$D_IN),
						   .ENQ(in_fifo$ENQ),
						   .DEQ(in_fifo$DEQ),
						   .CLR(in_fifo$CLR),
						   .D_OUT(in_fifo$D_OUT),
						   .FULL_N(in_fifo$FULL_N),
						   .EMPTY_N(in_fifo$EMPTY_N));

  // submodule outQ
  FIFO2 #(.width(32'd32), .guarded(32'd1)) outQ(.RST(RST_N),
						.CLK(CLK),
						.D_IN(outQ$D_IN),
						.ENQ(outQ$ENQ),
						.DEQ(outQ$DEQ),
						.CLR(outQ$CLR),
						.D_OUT(outQ$D_OUT),
						.FULL_N(outQ$FULL_N),
						.EMPTY_N(outQ$EMPTY_N));

  // register clk
  assign clk$D_IN = clk + 32'd1 ;
  assign clk$EN = 1'd1 ;

  // register count
  assign count$D_IN = count + 32'd1 ;
  assign count$EN = EN_put ;

  // register send
  assign send$D_IN = send + 32'd1 ;
  assign send$EN = EN_get ;

  // submodule dut
  assign dut$put_datas = in_fifo$D_OUT ;
  assign dut$EN_put = dut$RDY_put && in_fifo$EMPTY_N ;
  assign dut$EN_get = dut$RDY_get && outQ$FULL_N ;

  // submodule in_fifo
  assign in_fifo$D_IN = put_datas ;
  assign in_fifo$ENQ = EN_put ;
  assign in_fifo$DEQ = dut$RDY_put && in_fifo$EMPTY_N ;
  assign in_fifo$CLR = 1'b0 ;

  // submodule outQ
  assign outQ$D_IN = dut$get ;
  assign outQ$ENQ = dut$RDY_get && outQ$FULL_N ;
  assign outQ$DEQ = EN_get ;
  assign outQ$CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        clk <= `BSV_ASSIGNMENT_DELAY 32'd0;
	count <= `BSV_ASSIGNMENT_DELAY 32'd0;
	send <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (clk$EN) clk <= `BSV_ASSIGNMENT_DELAY clk$D_IN;
	if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
	if (send$EN) send <= `BSV_ASSIGNMENT_DELAY send$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    clk = 32'hAAAAAAAA;
    count = 32'hAAAAAAAA;
    send = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkHardware

